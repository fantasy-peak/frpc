// Generated by FRPC {{node.property.version}}

namespace {{node.property.namespace}} {

enum class {{value.caller}}{{value.callee}} : uint16_t {
    {% for func in value.definitions %}
        {{func.func_name}} = {{ loop.index1 }},
    {% endfor %}
};

} // {{node.property.namespace}}

MSGPACK_ADD_ENUM({{node.property.namespace}}::{{value.caller}}{{value.callee}})

namespace {{node.property.namespace}} {

class {{value.caller}} final {
public:
        {{value.caller}}(const frpc::ChannelConfig& config,
              const std::function<void(std::string)>& error)
              : m_channel(std::make_unique<frpc::BiChannel>(config, error, [this](auto& recv_msgs) mutable { dispatch(recv_msgs); }))
              , m_error(error) {
        }
        {{value.caller}}(const frpc::ChannelConfig& config,
              const std::shared_ptr<zmq::context_t>& context_ptr,
              const std::shared_ptr<zmq::socket_t>& socket_ptr,
              const std::function<void(std::string)>& error)
              : m_channel(std::make_unique<frpc::BiChannel>(config, context_ptr, socket_ptr, error, [this](auto& recv_msgs) mutable { dispatch(recv_msgs); }))
              , m_error(error) {
        }
        {{value.caller}}(const frpc::ChannelConfig& config,
              const std::shared_ptr<zmq::context_t>& context_ptr,
              const std::function<void(std::string)>& error)
              : m_channel(std::make_unique<frpc::BiChannel>(config, context_ptr, error, [this](auto& recv_msgs) mutable { dispatch(recv_msgs); }))
              , m_error(error) {
        }

        {{value.caller}}(const {{value.caller}}&) = delete;
        {{value.caller}}& operator=(const {{value.caller}}&) = delete;
        {{value.caller}}({{value.caller}}&&) = delete;
        {{value.caller}}& operator=({{value.caller}}&&) = delete;

        void start() {
            m_channel->start();
        }

        void stop() {
            if (m_channel)
                m_channel->stop();
        }

        decltype(auto) socket() {
            return m_channel->socket();
        }

        decltype(auto) context() {
            return m_channel->context();
        }

        bool monitor(std::function<void(std::tuple<zmq_event_t, std::string>)> cb, int events = ZMQ_EVENT_ALL) {
            return m_channel->monitor(std::move(cb), events);
        }

    {% for func in value.definitions %}

        void {{func.func_name}}({{_format_args(func.inputs)}}, std::function<void({{_format_args_type(func.outputs)}})> cb) {
            auto req_id = frpc::createUuid();
            auto snd_bufs = makeRequestPacket<{{value.caller}}{{value.callee}}::{{func.func_name}}>(
                req_id,
                std::make_tuple({{_format_args_name_and_move(func.inputs)}}));
            {
                std::lock_guard lk(m_mtx);
                m_cb.emplace(req_id, std::move(cb));
            }
            m_channel->send(std::move(snd_bufs));
        }

        void {{func.func_name}}({{_format_args(func.inputs)}},
            std::function<void({{_format_args_type(func.outputs)}})> cb,
            const std::chrono::milliseconds& timeout,
            std::function<void()> timeout_cb) {
            auto req_id = frpc::createUuid();
            auto snd_bufs = makeRequestPacket<{{value.caller}}{{value.callee}}::{{func.func_name}}>(
                req_id,
                std::make_tuple({{_format_args_name_and_move(func.inputs)}}));
            {
                std::lock_guard lk(m_mtx);
                m_cb.emplace(req_id, std::move(cb));
                m_timeout_cb.emplace(req_id, std::move(timeout_cb));
            }
            m_channel->send(std::move(snd_bufs), timeout, [this, req_id] { callTimeoutCallback(req_id); });
        }
#ifdef __cpp_impl_coroutine
    template <asio::completion_token_for<void({{_format_args_type(func.outputs)}})> CompletionToken>
    auto {{func.func_name}}_coro({{_format_args(func.inputs)}}, CompletionToken&& token) {
        return asio::async_initiate<CompletionToken, void({{_format_args_type(func.outputs)}})>(
            [this]<typename Handler>(Handler&& handler, {{_format_args(func.inputs)}}) mutable {
                auto handler_ptr = std::make_shared<Handler>(std::forward<Handler>(handler));
                this->{{func.func_name}}(
                        {{_format_args_name_and_move(func.inputs)}},
                        [handler_ptr = std::move(handler_ptr)]({{_format_args(func.outputs)}}) mutable {
                            auto ex = asio::get_associated_executor(*handler_ptr);
                            asio::post(ex, [{{_format_catch_move(func.outputs)}}, handler_ptr = std::move(handler_ptr)] () mutable -> void {
                                (*handler_ptr)({{_format_args_name_and_move(func.outputs)}});
                            });
                        });
            },
            token,
            {{_format_args_name_and_move(func.inputs)}});
    }

    template <asio::completion_token_for<void(std::optional<std::tuple<{{_format_args_type(func.outputs)}}>>)> CompletionToken>
    auto {{func.func_name}}_coro({{_format_args(func.inputs)}}, const std::chrono::milliseconds& timeout, CompletionToken&& token) {
        return asio::async_initiate<CompletionToken, void(std::optional<std::tuple<{{_format_args_type(func.outputs)}}>>)>(
            [this]<typename Handler>(Handler&& handler, {{_format_args(func.inputs)}}, const auto& timeout) mutable {
                auto handler_ptr = std::make_shared<Handler>(std::forward<Handler>(handler));
                this->{{func.func_name}}(
                            {{_format_args_name_and_move(func.inputs)}},
                            [handler_ptr]({{_format_args(func.outputs)}}) mutable {
                                auto ex = asio::get_associated_executor(*handler_ptr);
                                asio::post(ex, [{{_format_catch_move(func.outputs)}}, handler_ptr = std::move(handler_ptr)] () mutable -> void {
                                    (*handler_ptr)(std::make_tuple({{_format_args_name_and_move(func.outputs)}}));
                                });
                            },
                            timeout,
                            [handler_ptr] () mutable {
                                auto ex = asio::get_associated_executor(*handler_ptr);
                                asio::post(ex, [=, handler_ptr = std::move(handler_ptr)] () mutable -> void {
                                    (*handler_ptr)(std::nullopt);
                                });
                            });
            },
            token,
            {{_format_args_name_and_move(func.inputs)}}, timeout);
    }

    auto {{func.func_name}}_coro({{_format_args(func.inputs)}}) {
        return frpc::CallbackAwaiter<std::tuple<{{_format_args_type(func.outputs)}}>>{
            [this, {{_format_catch_move(func.inputs)}}](std::coroutine_handle<> handle, auto set_resume_value) mutable {
                this->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}},
                        [handle, set_resume_value = std::move(set_resume_value)]({{_format_args(func.outputs)}}) mutable {
                            set_resume_value(std::make_tuple({{_format_args_name_and_move(func.outputs)}}));
                            handle.resume();
                        });
            }};
    }

    auto {{func.func_name}}_coro({{_format_args(func.inputs)}}, const std::chrono::milliseconds& timeout) {
        return frpc::CallbackAwaiter<std::optional<std::tuple<{{_format_args_type(func.outputs)}}>>>{
            [this, {{_format_catch_move(func.inputs)}}, &timeout](std::coroutine_handle<> handle, auto set_resume_value) mutable {
                this->{{func.func_name}}(
                        {{_format_args_name_and_move(func.inputs)}},
                        [handle, set_resume_value]({{_format_args(func.outputs)}}) mutable {
                            set_resume_value(std::make_tuple({{_format_args_name_and_move(func.outputs)}}));
                            handle.resume();
                        },
                        timeout,
                        [handle, set_resume_value]()  {
                            set_resume_value(std::nullopt);
                            handle.resume();
                        });
            }};
    }

#endif

    {% endfor %}


    static auto create(frpc::ChannelConfig& config, std::function<void(std::string)> error) {
        config.socktype = zmq::socket_type::dealer;
        return std::make_unique<{{value.caller}}>(config, std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        const std::shared_ptr<zmq::socket_t>& socket_ptr,
        std::function<void(std::string)> error) {
        return std::make_unique<{{value.caller}}>(config, context_ptr, socket_ptr, std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        std::function<void(std::string)> error) {
        config.socktype = zmq::socket_type::dealer;
        return std::make_unique<{{value.caller}}>(config, context_ptr, std::move(error));
    }

private:
    template <{{value.caller}}{{value.callee}} type, typename T>
    std::vector<zmq::message_t> makeRequestPacket(const std::string& req_id, T&& t) {
        auto header = std::make_tuple(req_id, type);
        auto buffer = frpc::pack<decltype(header)>(header);
        auto packet = frpc::pack<T>(std::forward<T>(t));

        std::vector<zmq::message_t> snd_bufs;
        snd_bufs.emplace_back(zmq::message_t(buffer.data(), buffer.size()));
        snd_bufs.emplace_back(zmq::message_t(packet.data(), packet.size()));
        return snd_bufs;
    }

    void callTimeoutCallback(const std::string& req_id) {
        std::unique_lock lk(m_mtx);
        if (m_timeout_cb.find(req_id) == m_timeout_cb.end())
            return;
        auto cb = std::move(m_timeout_cb[req_id]);
        m_timeout_cb.erase(req_id);
        m_cb.erase(req_id);
        lk.unlock();
        cb();
    }

    void dispatch(std::vector<zmq::message_t>& recv_bufs) {
        if (recv_bufs.size() != 2) {
            m_error(FRPC_ERROR_FORMAT("Illegal response packet"));
            return;
        }
        try {
            using FrpcHeader = std::tuple<std::string, {{value.caller}}{{value.callee}}>;
            auto [req_id, req_type] = frpc::unpack<FrpcHeader>(recv_bufs[0].data(), recv_bufs[0].size());
            std::unique_lock lk(m_mtx);
            if (m_cb.find(req_id) == m_cb.end())
                return;
            auto cb = std::move(m_cb[req_id]);
            m_cb.erase(req_id);
            m_timeout_cb.erase(req_id);
            lk.unlock();
            switch(req_type) {
            {% for func in value.definitions %}
                case {{value.caller}}{{value.callee}}::{{func.func_name}}: {
                    auto [{{_format_args_name(func.outputs)}}] = frpc::unpack<std::tuple<{{_format_args_type(func.outputs)}}>>(recv_bufs[1].data(), recv_bufs[1].size());
                    auto callback = std::any_cast<std::function<void({{_format_args_type(func.outputs)}})>>(cb);
                    callback({{_format_args_name_and_move(func.outputs)}});
                    break;
                }
            {% endfor %}
            default:
                m_error(FRPC_ERROR_FORMAT("error type"));
            }
        } catch (const msgpack::type_error& error) {
             m_error(FRPC_ERROR_FORMAT(error.what()));
        } catch (const std::bad_any_cast& error) {
             m_error(FRPC_ERROR_FORMAT(error.what()));
        } catch (const std::exception& error) {
             m_error(FRPC_ERROR_FORMAT(error.what()));
        }
    }

    std::unique_ptr<frpc::BiChannel> m_channel;
    std::function<void(std::string)> m_error;
    std::mutex m_mtx;
    std::unordered_map<std::string, std::any> m_cb;
    std::unordered_map<std::string, std::function<void()>> m_timeout_cb;
};

struct {{value.callee}}Handler {
    {{value.callee}}Handler() = default;
    virtual ~{{value.callee}}Handler() = default;

    {% for func in value.definitions %}
        virtual void {{func.func_name}}({{_format_args(func.inputs)}}, std::function<void({{_format_args_type(func.outputs)}})> cb) noexcept = 0;
    {% endfor %}
};

struct AsioCoro{{value.callee}}Handler {
    AsioCoro{{value.callee}}Handler() = default;
    virtual ~AsioCoro{{value.callee}}Handler() = default;

#ifdef __cpp_impl_coroutine
    {% for func in value.definitions %}
        virtual asio::awaitable<void> {{func.func_name}}({{_format_args(func.inputs)}}, std::function<void({{_format_args_type(func.outputs)}})> cb) noexcept = 0;
    {% endfor %}
#else
    {% for func in value.definitions %}
        virtual void {{func.func_name}}({{_format_args(func.inputs)}}, std::function<void({{_format_args_type(func.outputs)}})> cb) noexcept = 0;
    {% endfor %}
#endif
};

struct FrpcCoro{{value.callee}}Handler {
    FrpcCoro{{value.callee}}Handler() = default;
    virtual ~FrpcCoro{{value.callee}}Handler() = default;

#ifdef __cpp_impl_coroutine
    {% for func in value.definitions %}
        virtual frpc::Task<void> {{func.func_name}}({{_format_args(func.inputs)}}, std::function<void({{_format_args_type(func.outputs)}})> cb) noexcept = 0;
    {% endfor %}
#else
    {% for func in value.definitions %}
        virtual void {{func.func_name}}({{_format_args(func.inputs)}}, std::function<void({{_format_args_type(func.outputs)}})> cb) noexcept = 0;
    {% endfor %}
#endif
};

class {{value.callee}} final {
public:
    using VariantHandler = std::variant<std::shared_ptr<FrpcCoro{{value.callee}}Handler>, std::shared_ptr<AsioCoro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>>;

    {{value.callee}}(const frpc::ChannelConfig& config,
        VariantHandler handler,
            std::function<void(std::string)> error)
            : m_handler(std::move(handler))
            , m_error(error) {
#ifdef __cpp_impl_coroutine
            m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
            m_pool_ptr->start();
#endif
            m_channel = std::make_unique<frpc::BiChannel>(config, error, [this] (std::vector<zmq::message_t>& recv_bufs) mutable {
                dispatch(recv_bufs);
            });
        }
    {{value.callee}}(const frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        const std::shared_ptr<zmq::socket_t>& socket_ptr,
        VariantHandler handler,
        std::function<void(std::string)> error)
            : m_handler(std::move(handler))
            , m_error(error) {
#ifdef __cpp_impl_coroutine
            m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
            m_pool_ptr->start();
#endif
            m_channel = std::make_unique<frpc::BiChannel>(config, context_ptr, socket_ptr, error, [this] (std::vector<zmq::message_t>& recv_bufs) mutable {
                dispatch(recv_bufs);
            });
    }
    {{value.callee}}(const frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        VariantHandler handler,
            std::function<void(std::string)> error)
            : m_handler(std::move(handler))
            , m_error(error) {
#ifdef __cpp_impl_coroutine
            m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
            m_pool_ptr->start();
#endif
            m_channel = std::make_unique<frpc::BiChannel>(config, context_ptr, error, [this] (std::vector<zmq::message_t>& recv_bufs) mutable {
                dispatch(recv_bufs);
            });
    }
    ~{{value.callee}}() {
        stop();
#ifdef __cpp_impl_coroutine
        if (m_pool_ptr)
            m_pool_ptr->stop();
#endif
    }

    {{value.callee}}(const {{value.callee}}&) = delete;
    {{value.callee}}& operator=(const {{value.callee}}&) = delete;
    {{value.callee}}({{value.callee}}&&) = delete;
    {{value.callee}}& operator=({{value.callee}}&&) = delete;

    auto& socket() {
        return m_channel->socket();
    }

    auto& context() {
        return m_channel->context();
    }

    bool monitor(std::function<void(std::tuple<zmq_event_t, std::string>)> cb, int events = ZMQ_EVENT_ALL) {
        return m_channel->monitor(std::move(cb), events);
    }

    void start() {
        m_channel->start();
    }

    void stop() {
        if (m_channel)
            m_channel->stop();
    }

    static auto create(frpc::ChannelConfig& config,
        VariantHandler handler,
        std::function<void(std::string)> error) {
        config.socktype = zmq::socket_type::router;
        config.bind = true;
        return std::make_unique<{{value.callee}}>(config, std::move(handler), std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        const std::shared_ptr<zmq::socket_t>& socket_ptr,
        VariantHandler handler,
        std::function<void(std::string)> error) {
        config.bind = true;
        return std::make_unique<{{value.callee}}>(config, context_ptr, socket_ptr, std::move(handler), std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        VariantHandler handler,
        std::function<void(std::string)> error) {
        config.socktype = zmq::socket_type::router;
        config.bind = true;
        return std::make_unique<{{value.callee}}>(config, context_ptr, std::move(handler), std::move(error));
    }

private:
    void dispatch(std::vector<zmq::message_t>& recv_bufs) {
        if (recv_bufs.size() != 3) {
            m_error(FRPC_ERROR_FORMAT("BiChannel recv illegal request packet"));
            return;
        }
        try {
            using FrpcHeader = std::tuple<std::string, {{value.caller}}{{value.callee}}>;
            [[maybe_unused]] auto [req_id, req_type] = frpc::unpack<FrpcHeader>(recv_bufs[1].data(), recv_bufs[1].size());
            switch(req_type) {
            {% for func in value.definitions %}
                case {{value.caller}}{{value.callee}}::{{func.func_name}}: {
                    auto tp = frpc::unpack<std::tuple<{{_format_args_type(func.inputs)}}>>(recv_bufs[2].data(), recv_bufs[2].size());
                    auto recv_bufs_ptr = std::make_shared<std::vector<zmq::message_t>>(std::move(recv_bufs));
                    // Don't call it in multiple threads
                    std::function<void({{_format_args_type(func.outputs)}})> out = [done = false, recv_bufs_ptr = std::move(recv_bufs_ptr), this] ({{_format_args(func.outputs)}}) mutable {
                        if (done)
                            return;
                        done = true;
                        auto& snd_bufs = *recv_bufs_ptr;
                        auto packet = frpc::pack<std::tuple<{{_format_args_type(func.outputs)}}>>(std::make_tuple({{_format_args_name_and_move(func.outputs)}}));
                        snd_bufs[2] = zmq::message_t(packet.data(), packet.size());
                        m_channel->send(std::move(snd_bufs));
                    };
                    std::visit([&](auto&& arg) mutable {
                        auto& [{{_format_args_name(func.inputs)}}] = tp;
                        using T = std::decay_t<decltype(arg)>;
                        if constexpr (std::is_same_v<T, std::shared_ptr<{{value.callee}}Handler>>) {
                            arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}}, std::move(out));
                        } else if constexpr (std::is_same_v<T, std::shared_ptr<AsioCoro{{value.callee}}Handler>>) {
#ifdef __cpp_impl_coroutine
                            asio::co_spawn(
                                m_pool_ptr->getIoContext(),
                                arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}}, std::move(out)),
                                asio::detached);
#else
                            arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}}, std::move(out));
#endif
                        } else {
#ifdef __cpp_impl_coroutine
                            [](auto& arg, auto tp, auto out) mutable -> frpc::AsyncTask {
                                auto& [{{_format_args_name(func.inputs)}}] = tp;
                                co_await arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}}, std::move(out));
                            }(arg, std::move(tp), std::move(out));
#else
                            arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}}, std::move(out));
#endif
                        }
                    },
                    m_handler);
                    break;
                }
            {% endfor %}
            default:
                m_error(FRPC_ERROR_FORMAT("error type"));
            }
        } catch (const msgpack::type_error& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        } catch (const std::bad_any_cast& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        } catch (const std::exception& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        }
    }

    std::variant<std::shared_ptr<FrpcCoro{{value.callee}}Handler>, std::shared_ptr<AsioCoro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>> m_handler;
    std::function<void(std::string)> m_error;
    std::unique_ptr<frpc::BiChannel> m_channel;
    std::mutex m_mtx;
#ifdef __cpp_impl_coroutine
    std::unique_ptr<frpc::ContextPool> m_pool_ptr;
#endif
}; 

} // {{node.property.namespace}}
