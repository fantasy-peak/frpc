// Generated by FRPC {{node.property.version}}

namespace {{node.property.namespace}} {

enum class {{value.caller}}{{value.callee}} : uint16_t {
    {% for func in value.definitions %}
        {{func.func_name}} = {{ loop.index1 }},
    {% endfor %}
};

} // {{node.property.namespace}}

MSGPACK_ADD_ENUM({{node.property.namespace}}::{{value.caller}}{{value.callee}})

namespace {{node.property.namespace}} {

#ifdef __cpp_impl_coroutine

class {{value.caller}} final {
public:
    {{value.caller}}(const frpc::ChannelConfig& config,
        std::function<void(std::string)> error)
        : m_config(config)
        , m_channel(std::make_unique<frpc::BiChannel>(config, error, [this](auto& recv_msgs) mutable {
            dispatch(recv_msgs);
        }))
        , m_error(error) {
        m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
        m_pool_ptr->start();
    }
    {{value.caller}}(const frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        const std::shared_ptr<zmq::socket_t>& socket_ptr,
        std::function<void(std::string)> error)
        : m_config(config)
        , m_channel(std::make_unique<frpc::BiChannel>(config, context_ptr, socket_ptr, error, [this](auto& recv_msgs) mutable {
            dispatch(recv_msgs);
        }))
        , m_error(error) {
        m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
        m_pool_ptr->start();
    }
    {{value.caller}}(const frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        std::function<void(std::string)> error)
        : m_config(config)
        , m_channel(std::make_unique<frpc::BiChannel>(config, context_ptr, error, [this](auto& recv_msgs) mutable {
            dispatch(recv_msgs);
        }))
        , m_error(error) {
        m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
        m_pool_ptr->start();
    }
    ~{{value.caller}}() {
        if (m_pool_ptr)
            m_pool_ptr->stop();
    }

    {{value.caller}}(const {{value.caller}}&) = delete;
    {{value.caller}}& operator=(const {{value.caller}}&) = delete;
    {{value.caller}}({{value.caller}}&&) = delete;
    {{value.caller}}& operator=({{value.caller}}&&) = delete;

    void start() {
        m_channel->start();
    }

    decltype(auto) socket() {
        return m_channel->socket();
    }

    decltype(auto) context() {
        return m_channel->context();
    }

    {% for func in value.definitions %}

    auto {{func.func_name}}() {
        auto req_id = frpc::createUuid();
        auto header = std::make_tuple(req_id, {{value.caller}}{{value.callee}}::{{func.func_name}});

        auto buffer = frpc::pack<decltype(header)>(header);
        std::string header_str((char*)buffer.data(), buffer.size());

        auto stream_ptr = std::make_shared<frpc::Stream<void({{_format_args_type(func.inputs)}})>>(
            [this, header_str = std::move(header_str)] ({{_format_args(func.inputs)}}) mutable {
                auto packet = frpc::pack<std::tuple<{{_format_args_type(func.inputs)}}>>(std::make_tuple({{_format_args_name_and_move(func.inputs)}}));
                std::vector<zmq::message_t> snd_bufs;
                snd_bufs.emplace_back(zmq::message_t(header_str.data(), header_str.size()));
                snd_bufs.emplace_back(zmq::message_t(packet.data(), packet.size()));
                m_channel->send(std::move(snd_bufs));
            },
            [] {});
        auto channel_ptr = std::make_shared<asio::experimental::concurrent_channel<void(frpc::error_code, {{_format_args_type(func.outputs)}})>>(
            m_pool_ptr->getIoContext(),
            m_config.channel_size);
        {
            std::function<void(std::tuple<{{_format_args_type(func.outputs)}}>)> func = [channel_ptr, this](std::tuple<{{_format_args_type(func.outputs)}}> tp) mutable {
                auto& [{{_format_args_name(func.outputs)}}] = tp;
                if (!channel_ptr->try_send(frpc::error_code{}, {{_format_args_name_and_move(func.outputs)}}))
                    m_error(FRPC_ERROR_FORMAT("Failed to store message to channel!!!"));
            };
            std::lock_guard lk(m_mtx);
            m_cb.emplace(req_id, std::move(func));
            m_close_cb.emplace(req_id, [channel_ptr] { channel_ptr->close(); });
        }
        return std::make_tuple(stream_ptr, channel_ptr);
    }

    {% endfor %}

    static auto create(frpc::ChannelConfig& config, std::function<void(std::string)> error) {
        config.socktype = zmq::socket_type::dealer;
        return std::make_unique<{{value.caller}}>(config, std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        const std::shared_ptr<zmq::socket_t>& socket_ptr,
        std::function<void(std::string)> error) {
        return std::make_unique<{{value.caller}}>(config, context_ptr, socket_ptr, std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        std::function<void(std::string)> error) {
        config.socktype = zmq::socket_type::dealer;
        return std::make_unique<{{value.caller}}>(config, context_ptr, std::move(error));
    }

    bool monitor(std::function<void(std::tuple<zmq_event_t, std::string>)> cb, int events = ZMQ_EVENT_ALL) {
        return m_channel->monitor(std::move(cb), events);
    }

private:
    void dispatch(std::vector<zmq::message_t>& recv_bufs) {
        if (recv_bufs.size() != 2) {
            m_error(FRPC_ERROR_FORMAT("client recv invalid stream server response packets!!!"));
            return;
        }
        try {
            using FrpcHeader = std::tuple<std::string, {{value.caller}}{{value.callee}}, bool>;
            auto [req_id, req_type, is_close] = frpc::unpack<FrpcHeader>(recv_bufs[0].data(), recv_bufs[0].size());
            if (is_close) {
                std::unique_lock lk(m_mtx);
                m_cb.erase(req_id);
                m_close_cb[req_id]();
                m_close_cb.erase(req_id);
                return;
            }
            switch (req_type) {
                {% for func in value.definitions %}
                    case {{value.caller}}{{value.callee}}::{{func.func_name}}: {
                        auto [{{_format_args_name(func.outputs)}}] = frpc::unpack<std::tuple<{{_format_args_type(func.outputs)}}>>(recv_bufs[1].data(), recv_bufs[1].size());
                        std::unique_lock lk(m_mtx);
                        if (m_cb.find(req_id) == m_cb.end())
                            break;
                        auto& cb = m_cb[req_id];
                        auto callback = std::any_cast<std::function<void(std::tuple<{{_format_args_type(func.outputs)}}>)>>(cb);
                        lk.unlock();
                        callback({{_format_args_name_and_move(func.outputs)}});
                        break;
                    }
                {% endfor %}
                default:
                    m_error(FRPC_ERROR_FORMAT("error type"));
            }
        } catch (const msgpack::type_error& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        } catch (const std::bad_any_cast& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        } catch (const std::exception& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        }
    }

    frpc::ChannelConfig m_config;
    std::unique_ptr<frpc::BiChannel> m_channel;
    std::function<void(std::string)> m_error;
    std::mutex m_mtx;
    std::unordered_map<std::string, std::any> m_cb;
    std::unordered_map<std::string, std::function<void()>> m_close_cb;
    std::unique_ptr<frpc::ContextPool> m_pool_ptr;
};

struct {{value.callee}}Handler {
    {{value.callee}}Handler() = default;
    virtual ~{{value.callee}}Handler() = default;

    {% for func in value.definitions %}
    virtual void {{func.func_name}}(std::shared_ptr<asio::experimental::concurrent_channel<void(frpc::error_code, {{_format_args_type(func.inputs)}})>>,
        std::shared_ptr<frpc::Stream<void({{_format_args_type(func.outputs)}})>>) noexcept = 0;
    {% endfor %}
};

struct Coro{{value.callee}}Handler {
    Coro{{value.callee}}Handler() = default;
    virtual ~Coro{{value.callee}}Handler() = default;

    {% for func in value.definitions %}
#ifdef __cpp_impl_coroutine
    virtual asio::awaitable<void> {{func.func_name}}(std::shared_ptr<asio::experimental::concurrent_channel<void(frpc::error_code, {{_format_args_type(func.inputs)}})>>,
        std::shared_ptr<frpc::Stream<void({{_format_args_type(func.outputs)}})>>) noexcept = 0;
#else
    virtual void {{func.func_name}}(std::shared_ptr<asio::experimental::concurrent_channel<void(frpc::error_code, {{_format_args_type(func.inputs)}})>>,
        std::shared_ptr<frpc::Stream<void({{_format_args_type(func.outputs)}})>>) noexcept = 0;
#endif
    {% endfor %}
};

class {{value.callee}} final {
public:
    {{value.callee}}(const frpc::ChannelConfig& config,
        std::variant<std::shared_ptr<Coro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>> handler,
        std::function<void(std::string)> error)
        : m_config(config)
        , m_handler(std::move(handler))
        , m_error(error) {
        m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
        m_pool_ptr->start();
        m_channel = std::make_unique<frpc::BiChannel>(config, error, [this] (auto& recv_bufs) { dispatch(recv_bufs); });
    }
    {{value.callee}}(const frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        const std::shared_ptr<zmq::socket_t>& socket_ptr,
        std::variant<std::shared_ptr<Coro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>> handler,
        std::function<void(std::string)> error)
        : m_config(config)
        , m_handler(std::move(handler))
        , m_error(error) {
        m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
        m_pool_ptr->start();
        m_channel = std::make_unique<frpc::BiChannel>(config, context_ptr, socket_ptr, error, [this] (auto& recv_bufs) { dispatch(recv_bufs); });
    }
    {{value.callee}}(const frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        std::variant<std::shared_ptr<Coro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>> handler,
        std::function<void(std::string)> error)
        : m_config(config)
        , m_handler(std::move(handler))
        , m_error(error) {
        m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
        m_pool_ptr->start();
        m_channel = std::make_unique<frpc::BiChannel>(config, context_ptr, error, [this] (auto& recv_bufs) { dispatch(recv_bufs); });
    }
    ~{{value.callee}}() {
        if (m_pool_ptr)
            m_pool_ptr->stop();
    }

    {{value.callee}}(const {{value.callee}}&) = delete;
    {{value.callee}}& operator=(const {{value.callee}}&) = delete;
    {{value.callee}}({{value.callee}}&&) = delete;
    {{value.callee}}& operator=({{value.callee}}&&) = delete;

    decltype(auto) socket() {
        return m_channel->socket();
    }

    decltype(auto) context() {
        return m_channel->context();
    }

    void start() {
        m_channel->start();
    }

    static auto create(frpc::ChannelConfig& config,
        std::variant<std::shared_ptr<Coro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>> handler,
        std::function<void(std::string)> error) {
        config.socktype = zmq::socket_type::router;
        config.bind = true;
        return std::make_unique<{{value.callee}}>(config, std::move(handler), std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        const std::shared_ptr<zmq::socket_t>& socket_ptr,
        std::variant<std::shared_ptr<Coro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>> handler,
        std::function<void(std::string)> error) {
        config.socktype = zmq::socket_type::router;
        config.bind = true;
        return std::make_unique<{{value.callee}}>(config, context_ptr, socket_ptr, std::move(handler), std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        std::variant<std::shared_ptr<Coro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>> handler,
        std::function<void(std::string)> error) {
        config.socktype = zmq::socket_type::router;
        config.bind = true;
        return std::make_unique<{{value.callee}}>(config, context_ptr, std::move(handler), std::move(error));
    }

    bool monitor(std::function<void(std::tuple<zmq_event_t, std::string>)> cb, int events = ZMQ_EVENT_ALL) {
        return m_channel->monitor(std::move(cb), events);
    }

private:
    void dispatch(std::vector<zmq::message_t>& recv_bufs) {
        if (recv_bufs.size() != 3) {
            m_error(FRPC_ERROR_FORMAT("server recv invalid stream client request packets!!!"));
            return;
        }
        try {
            using FrpcHeader = std::tuple<std::string, {{value.caller}}{{value.callee}}>;
            auto [req_id, req_type] = frpc::unpack<FrpcHeader>(recv_bufs[1].data(), recv_bufs[1].size());
            switch(req_type) {
            {% for func in value.definitions %}
                case {{value.caller}}{{value.callee}}::{{func.func_name}}: {
                    auto tp = frpc::unpack<std::tuple<{{_format_args_type(func.inputs)}}>>(recv_bufs[2].data(), recv_bufs[2].size());
                    auto& [{{_format_args_name(func.inputs)}}] = tp;
                    std::shared_ptr<asio::experimental::concurrent_channel<void(frpc::error_code, {{_format_args_type(func.inputs)}})>> channel_ptr;
                    {
                        std::lock_guard lk(m_mtx);
                        if (m_channel_mapping.contains(req_id)) {
                            channel_ptr = std::any_cast<decltype(channel_ptr)>(m_channel_mapping[req_id]);
                            if (!channel_ptr->try_send(frpc::error_code{}, {{_format_args_name_and_move(func.inputs)}}))
                                m_error(FRPC_ERROR_FORMAT("Failed to store message to channel!!!"));
                            return;
                        }
                        channel_ptr = std::make_shared<asio::experimental::concurrent_channel<void(frpc::error_code, {{_format_args_type(func.inputs)}})>>(
                            m_pool_ptr->getIoContext(), 
                            m_config.channel_size);
                        m_channel_mapping[req_id] = channel_ptr;
                    }
                    if (!channel_ptr->try_send(frpc::error_code{}, {{_format_args_name_and_move(func.inputs)}}))
                        m_error(FRPC_ERROR_FORMAT("Failed to store message to channel!!!"));

                    auto is_open = std::make_tuple(req_id, req_type, false);
                    auto is_open_buffer = frpc::pack<decltype(is_open)>(is_open);
                    auto is_close = std::make_tuple(req_id, req_type, true);
                    auto is_close_buffer = frpc::pack<decltype(is_close)>(is_close);
                    // set open stream flag
                    recv_bufs[1] = zmq::message_t(is_open_buffer.data(), is_open_buffer.size());
                    // set close stream flag
                    recv_bufs[2] = zmq::message_t(is_close_buffer.data(), is_close_buffer.size());
                    auto ptr = std::make_shared<std::vector<zmq::message_t>>(std::move(recv_bufs));

                    auto out = std::make_shared<frpc::Stream<void({{_format_args_type(func.outputs)}})>>(
                        [ptr, this] ({{_format_args(func.outputs)}}) mutable {
                            auto& recv_bufs = *ptr;
                            auto packet = frpc::pack<std::tuple<{{_format_args_type(func.outputs)}}>>(std::make_tuple({{_format_args_name_and_move(func.outputs)}}));
                            auto close = frpc::pack<bool>(false);
                            std::vector<zmq::message_t> snd_bufs;
                            snd_bufs.emplace_back(zmq::message_t(recv_bufs[0].data(), recv_bufs[0].size()));
                            snd_bufs.emplace_back(zmq::message_t(recv_bufs[1].data(), recv_bufs[1].size()));
                            snd_bufs.emplace_back(zmq::message_t(packet.data(), packet.size()));
                            m_channel->send(std::move(snd_bufs));
                        }, 
                        [ptr, this, req_id, channel_ptr] () mutable {
                            auto& recv_bufs = *ptr;
                            std::vector<zmq::message_t> snd_bufs;
                            snd_bufs.emplace_back(zmq::message_t(recv_bufs[0].data(), recv_bufs[0].size()));
                            snd_bufs.emplace_back(zmq::message_t(recv_bufs[2].data(), recv_bufs[2].size()));
                            snd_bufs.emplace_back(zmq::message_t("C", 1));
                            m_channel->send(std::move(snd_bufs));
                            channel_ptr->close();
                            {
                                std::lock_guard lk(m_mtx);
                                m_channel_mapping.erase(req_id);
                            }
                        });
                    std::visit([&](auto&& arg) mutable {
                        using T = std::decay_t<decltype(arg)>;
                        if constexpr (std::is_same_v<T, std::shared_ptr<{{value.callee}}Handler>>) {
                            arg->{{func.func_name}}(std::move(channel_ptr), std::move(out));
                        } else {
                            asio::co_spawn(
                                m_pool_ptr->getIoContext(),
                                arg->{{func.func_name}}(std::move(channel_ptr), std::move(out)),
                                asio::detached);
                        }
                    },
                    m_handler);
                    break;
                }
            {% endfor %}
            default:
                m_error(FRPC_ERROR_FORMAT("error type"));
            }
        } catch (const msgpack::type_error& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        } catch (const std::bad_any_cast& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        } catch (const std::exception& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        }
    }

    frpc::ChannelConfig m_config;
    std::variant<std::shared_ptr<Coro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>> m_handler;
    std::function<void(std::string)> m_error;
    std::unique_ptr<frpc::BiChannel> m_channel;
    std::mutex m_mtx;
    std::unique_ptr<frpc::ContextPool> m_pool_ptr;
    std::unordered_map<std::string, std::any> m_channel_mapping;
}; 

#endif

} // {{node.property.namespace}}
