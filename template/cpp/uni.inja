namespace {{node.property.namespace}} {

enum class {{value.caller}}{{value.callee}} : uint16_t {
    {% for func in value.definitions %}
        {{func.func_name}} = {{ loop.index1 }},
    {% endfor %}
};

inline std::string_view toString(const {{value.caller}}{{value.callee}} value) {
    switch (value) {
    {% for func in value.definitions %}
        case {{value.caller}}{{value.callee}}::{{func.func_name}}:
            return "{{func.func_name}}";
    {% endfor %}
    default:
        return "???";
    }
}

template <>
inline {{value.caller}}{{value.callee}} fromString<{{value.caller}}{{value.callee}}>(const std::string& value) {
    {% for func in value.definitions %}
    if (value == "{{func.func_name}}")
        return {{value.caller}}{{value.callee}}::{{func.func_name}};
    {% endfor %}
    throw std::bad_cast();
    }

} // {{node.property.namespace}}

MSGPACK_ADD_ENUM({{node.property.namespace}}::{{value.caller}}{{value.callee}})

namespace {{node.property.namespace}} {

struct {{value.callee}}Handler {
    {% for func in value.definitions %}
        virtual void {{func.func_name}}({{_format_args(func.inputs)}}) noexcept = 0;
    {% endfor %}
};

struct AsioCoro{{value.callee}}Handler {
#ifdef __cpp_impl_coroutine
    {% for func in value.definitions %}
        virtual asio::awaitable<void> {{func.func_name}}({{_format_args(func.inputs)}}) noexcept = 0;
    {% endfor %}
#else
    {% for func in value.definitions %}
        virtual void {{func.func_name}}({{_format_args(func.inputs)}}) noexcept = 0;
    {% endfor %}
#endif

};

struct FrpcCoro{{value.callee}}Handler {
#ifdef __cpp_impl_coroutine
    {% for func in value.definitions %}
        virtual frpc::Task<void> {{func.func_name}}({{_format_args(func.inputs)}}) noexcept = 0;
    {% endfor %}
#else
    {% for func in value.definitions %}
        virtual void {{func.func_name}}({{_format_args(func.inputs)}}) noexcept = 0;
    {% endfor %}
#endif
};

class {{value.callee}} final {
public:
    using VariantHandler = std::variant<std::shared_ptr<FrpcCoro{{value.callee}}Handler>, std::shared_ptr<AsioCoro{{value.callee}}Handler>, std::shared_ptr<{{value.callee}}Handler>>;
    {{value.callee}}(const frpc::ChannelConfig& config,
        VariantHandler handler,
        std::function<void(std::string)> error) 
        : m_handler(std::move(handler))
        , m_error(error) {
#ifdef __cpp_impl_coroutine
        m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
        m_pool_ptr->start();
#endif
        m_channel = std::make_unique<frpc::UniChannel>(config, [this](auto& recv) mutable { dispatch(recv); }, error);
    }
    {{value.callee}}(const frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        VariantHandler handler,
        std::function<void(std::string)> error)
        : m_handler(std::move(handler))
        , m_error(error) {
#ifdef __cpp_impl_coroutine
        m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
        m_pool_ptr->start();
#endif
        m_channel = std::make_unique<frpc::UniChannel>(config, context_ptr, [this](auto& recv_msgs) mutable { dispatch(recv_msgs); }, error);
    }
    {{value.callee}}(const frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        const std::shared_ptr<zmq::socket_t>& socket_ptr,
        VariantHandler handler,
        std::function<void(std::string)> error)
        : m_handler(std::move(handler))
        , m_error(error) {
#ifdef __cpp_impl_coroutine
        m_pool_ptr = std::make_unique<frpc::ContextPool>(config.context_pool_size);
        m_pool_ptr->start();
#endif
        m_channel = std::make_unique<frpc::UniChannel>(config, context_ptr, socket_ptr, [this](auto& recv_msgs) mutable { dispatch(recv_msgs); }, error);
    }
    ~{{value.callee}}() {
#ifdef __cpp_impl_coroutine
        if (m_pool_ptr)
            m_pool_ptr->stop();
#endif
    }

    void start() {
        m_channel->start();
    }

    decltype(auto) socket() {
        return m_channel->socket();
    }

    decltype(auto) context() {
        return m_channel->context();
    }

    static auto create(frpc::ChannelConfig& config,
        VariantHandler handler,
        std::function<void(std::string)> error) {
        if ((config.socktype != zmq::socket_type::sub) && config.socktype != zmq::socket_type::pull)
            config.socktype = zmq::socket_type::sub;
        if (config.socktype == zmq::socket_type::sub)
            config.bind = false;
        return std::make_unique<{{value.callee}}>(config, std::move(handler), std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        const std::shared_ptr<zmq::socket_t>& socket_ptr,
        VariantHandler handler,
        std::function<void(std::string)> error) {
        if ((config.socktype != zmq::socket_type::sub) && config.socktype != zmq::socket_type::pull)
            config.socktype = zmq::socket_type::sub;
        if (config.socktype == zmq::socket_type::sub)
            config.bind = false;
        return std::make_unique<{{value.callee}}>(config, context_ptr, socket_ptr, std::move(handler), std::move(error));
    }
    static auto create(frpc::ChannelConfig& config,
        const std::shared_ptr<zmq::context_t>& context_ptr,
        VariantHandler handler,
        std::function<void(std::string)> error) {
        if ((config.socktype != zmq::socket_type::sub) && config.socktype != zmq::socket_type::pull)
            config.socktype = zmq::socket_type::sub;
        if (config.socktype == zmq::socket_type::sub)
            config.bind = false;
        return std::make_unique<{{value.callee}}>(config, context_ptr, std::move(handler), std::move(error));
    }

    bool monitor(std::function<void(std::tuple<zmq_event_t, std::string>)> cb, int events = ZMQ_EVENT_ALL) {
        return m_channel->monitor(std::move(cb), events);
    }

private:
    void dispatch(std::vector<zmq::message_t>& recv_bufs) {
        if (recv_bufs.size() != 2) {
            m_error(FRPC_ERROR_FORMAT("Illegal response packet"));
            return;
        }
        try {
            auto req_type = frpc::unpack<{{value.caller}}{{value.callee}}>(recv_bufs[0].data(), recv_bufs[0].size());
            switch(req_type) {
            {% for func in value.definitions %}
                case {{value.caller}}{{value.callee}}::{{func.func_name}}: {
                    auto tp = frpc::unpack<std::tuple<{{_format_args_type(func.inputs)}}>>(recv_bufs[1].data(), recv_bufs[1].size());
                    std::visit(
                        [&](auto&& arg) {
                            auto& [{{_format_args_name(func.inputs)}}] = tp;
                            using T = std::decay_t<decltype(arg)>;
                            if constexpr (std::is_same_v<T, std::shared_ptr<{{value.callee}}Handler>>) {
                                arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}});
                            } else  if constexpr (std::is_same_v<T, std::shared_ptr<AsioCoro{{value.callee}}Handler>>) {
#ifdef __cpp_impl_coroutine
                                asio::co_spawn(
                                    m_pool_ptr->getIoContext(),
                                    arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}}),
                                    asio::detached);
#else
                                arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}});
#endif
                            } else {
#ifdef __cpp_impl_coroutine
                                [](auto& arg, auto tp) mutable -> frpc::AsyncTask {
                                    auto& [{{_format_args_name(func.inputs)}}] = tp;
                                    co_await arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}});
                                }(arg, std::move(tp));
#else
                                arg->{{func.func_name}}({{_format_args_name_and_move(func.inputs)}});
#endif
                            }
                        },
                        m_handler);
                    break;
                }
            {% endfor %}
            default:
                m_error(FRPC_ERROR_FORMAT("error type"));
            }
        } catch (const msgpack::type_error& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        } catch (const std::exception& error) {
            m_error(FRPC_ERROR_FORMAT(error.what()));
        }
    }

    VariantHandler m_handler;
    std::function<void(std::string)> m_error;
    std::unique_ptr<frpc::UniChannel> m_channel;
#ifdef __cpp_impl_coroutine
    std::unique_ptr<frpc::ContextPool> m_pool_ptr;
#endif
}; 

class {{value.caller}} final {
public:
        {{value.caller}}(const frpc::ChannelConfig& config)
            : m_context(std::make_shared<zmq::context_t>(config.io_threads))
            , m_socket(std::make_shared<zmq::socket_t>(*m_context, config.socktype)) {
            init_socket(config);
        }
        {{value.caller}}(const frpc::ChannelConfig& config,
            const std::shared_ptr<zmq::context_t>& context)
            : m_context(context)
            , m_socket(std::make_shared<zmq::socket_t>(*m_context, config.socktype)) {
            init_socket(config);
        }
        {{value.caller}}(const frpc::ChannelConfig& config,
            const std::shared_ptr<zmq::context_t>& context,
            const std::shared_ptr<zmq::socket_t>& socket)
            : m_context(context)
            , m_socket(socket) {
            init_socket(config);
        }

        ~{{value.caller}}() {}

        static auto create(frpc::ChannelConfig& config) {
            if ((config.socktype != zmq::socket_type::pub) && config.socktype != zmq::socket_type::push)
                config.socktype = zmq::socket_type::pub;
            if (config.socktype == zmq::socket_type::pub)
                config.bind = true;
            return std::make_unique<{{value.caller}}>(config);
        }
        static auto create(frpc::ChannelConfig& config,
            const std::shared_ptr<zmq::context_t>& context_ptr,
            const std::shared_ptr<zmq::socket_t>& socket_ptr) {
            if ((config.socktype != zmq::socket_type::pub) && config.socktype != zmq::socket_type::push)
                config.socktype = zmq::socket_type::pub;
            if (config.socktype == zmq::socket_type::pub)
                config.bind = true;
            return std::make_unique<{{value.caller}}>(config, context_ptr, socket_ptr);
        }
        static auto create(frpc::ChannelConfig& config,
            const std::shared_ptr<zmq::context_t>& context_ptr) {
            if ((config.socktype != zmq::socket_type::pub) && config.socktype != zmq::socket_type::push)
                config.socktype = zmq::socket_type::pub;
            if (config.socktype == zmq::socket_type::pub)
                config.bind = true;
            return std::make_unique<{{value.caller}}>(config, context_ptr);
        }

        {% for func in value.definitions %}
            auto {{func.func_name}} ({{_format_args(func.inputs)}}) {
                static auto pub_topic = frpc::pack<{{value.caller}}{{value.callee}}>({{value.caller}}{{value.callee}}::{{func.func_name}});
                auto str = frpc::pack<std::tuple<{{_format_args_type(func.inputs)}}>>(std::make_tuple({{_format_args_name_and_move(func.inputs)}}));
                std::vector<zmq::message_t> snd_bufs;
                snd_bufs.emplace_back(zmq::message_t(pub_topic.data(), pub_topic.size()));
                snd_bufs.emplace_back(zmq::message_t(str.data(), str.size()));
                std::lock_guard lk(m_mtx);
                auto ret = zmq::send_multipart(*m_socket, std::move(snd_bufs));
                return ret;
            }
        {% endfor %}

        auto& socket() {
            return m_socket;
        }

        auto& context() {
            return m_context;
        }
private:
    void init_socket(const frpc::ChannelConfig& config) {
        m_socket->set(zmq::sockopt::sndhwm, config.sendhwm);
        m_socket->set(zmq::sockopt::rcvhwm, config.recvhwm);
        m_socket->set(zmq::sockopt::sndbuf, config.sendbuf);
        m_socket->set(zmq::sockopt::rcvbuf, config.recvbuf);
        m_socket->set(zmq::sockopt::linger, config.linger);
        if (config.tcp_keepalive) {
            m_socket->set(zmq::sockopt::tcp_keepalive, 1);
            m_socket->set(zmq::sockopt::tcp_keepalive_idle, config.tcp_keepalive_idle);
            m_socket->set(zmq::sockopt::tcp_keepalive_cnt, config.tcp_keepalive_cnt);
            m_socket->set(zmq::sockopt::tcp_keepalive_intvl, config.tcp_keepalive_intvl);
        }
        if (config.bind)
            m_socket->bind(config.addr);
        else
            m_socket->connect(config.addr);
    }

    std::shared_ptr<zmq::context_t> m_context;
    std::shared_ptr<zmq::socket_t> m_socket;
    std::mutex m_mtx;
}; 

} // {{node.property.namespace}}
